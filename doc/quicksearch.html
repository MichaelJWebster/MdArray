<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"-_Users_michaelw_Google Drive_js_MdArray_lib_MdArray.js.html":{"id":"-_Users_michaelw_Google Drive_js_MdArray_lib_MdArray.js.html","title":"Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js","body":" DocStrap Classes ArrayViewMdArray Global assertenumerateDimsenumerateSlicesfindIndexflattengetStridesprocessSlicestoString Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js /* * MdArray * https://github.com/michaelw/MdArray * * A multi-dimensional array implementation for use in machine learning and * other calculations. * * Copyright (c) 2016 Michael Webster * Licensed under the MIT license. */ /* * FIXME: Need to add scalar multiplication/division, add etc. * */ var _us = require(&quot;underscore&quot;); 'use strict'; /** * @classdesc The MdArray class provides a multi-dimensional array like * abstraction for javascript. * * Construct an Ml_ndarray object from it's shape in terms of rows,columns, * and any other dimensions it has. * * The parameter to the constructor is a javascript object containing keyword * arguments. Eg.: * * { * data: [1, 2, 3, 4], * shape: [2, 2] * } * * @param arrayArgs An object containing the keyword args for the constructor. * @constructor */ var MdArray = function(arrayArgs) { 'use strict'; assert(arrayArgs.data, &quot;MdArray constructor must be called with an object having at &quot; + &quot;least one of the shape or data fields.&quot;); this.data = arrayArgs.data; this.dSize = this.data.length; var dims; var tSize; var strides; if (arrayArgs.shape) { dims = arrayArgs.shape; tSize = _us.reduce(dims, function(memo, val) { return memo * val; }, 1); strides = getStrides(dims); } else { dims = [arrayArgs.data.length]; tSize = arrayArgs.data.length; strides = [1]; } this.dims = dims; this.tSize = tSize; this.strides = strides; assert(this.tSize == this.dSize, &quot;Data must by the right size for the supplied dimenstions.&quot;); // Return this for chaining? return this; }; MdArray.prototype = { constructor: MdArray, /** * Get the value of the element indexed by the coordinate values in the * arguments. * * @returns The value at the array position specified. * @method */ get: function() { 'use strict'; var args = _us.toArray(arguments); var idx = this.findIndex(args); return this.data[idx]; }, /** * Set the value in the array element indexed by the remaining values in * arguments. * * @param val The value to be assigned into the array. * * @method */ set: function(val) { 'use strict'; var idx = this.findIndex(_us.rest(arguments)); this.data[idx] = val; }, /** * Return the required 1-d javascript array index indicated by the supplied * index coordinates. * * @param idx An array containing the coordinate of the requested element. * * @method */ findIndex: function(idx) { 'use strict'; assert(idx.length == this.strides.length, &quot;Wrong number of arguments to index array with &quot; + this.strides.length + &quot; dimensions.&quot;); var md_idx = _us.zip(idx, this.strides); return _us.reduce(md_idx, function(memo, val) { return memo + val[0] * val[1]; }, 0); }, /** * Return a string representation of the the multi-Dimensional array. * * @returns A readable string for the array. * * @method */ toString: function() { var idxInfo = _us.zip(this.dims.slice(0), this.strides.slice(0)); function ts(dimStrides, idx, data) { s = &quot;[&quot;; if (dimStrides.length == 1) { s += &quot;\\t&quot;; var first = dimStrides[0]; for (var i = 0; i &lt; first[0]; i++) { s += &quot; &quot; + data[idx + i * first[1]]; } s += &quot; ]&quot;; } else { var first = _us.first(dimStrides); for (var i = 0; i &lt; first[0]; i++) { s += ts(_us.rest(dimStrides), idx + i * first[1], data); if (i &lt; first[0] - 1) { s += &quot;\\n&quot;; } } s += &quot;]&quot;; } if (dimStrides.length == idxInfo.length) { s += &quot;\\n&quot;; } return s; } return ts(idxInfo, 0, this.data); }, /** * Return the data of this MdArray as a flat array. * * @method */ flatten: function() { return this.data; }, /** * Apply the function opFn to all pairs of matching elements in this and that. * * @param that The other object that is part of this operation. * @param opFn The operation to be applied to pairs of elements from this * and that. * * @returns A new MdArray containing the results of applying opFn to * this and that. * * @method */ applyOp: function(that, opFn) { var newData = null; if (that instanceof MdArray) { var compatible = this.compatible(that); if (compatible) { newData = _us.map(this.data, function(val, idx) { return opFn(val, that.data[idx]); }); } else { throw new Error(&quot;MdArray.applyOp: Incompatible sizes for arrays.&quot;); } } else { // multiply by scalar. newData = _us.map(this.data, function(val) { return opFn(val, that); }); } var newArray = new MdArray({data: newData, shape : this.dims.slice(0)}); return newArray; }, /** * Test whether the MdArray that is compatible with this one, so that * element wise operations are able to be applied between this and that. * * @param that An MdArray object to have it's dimensions checked against * this. * * @returns true =&gt; this and that are compatible, false otherwise. * * @method */ compatible: function(that) { var dims = _us.zip(this.dims, that.dims); return _us.every(dims, function(x) { return x[0] === x[1]; }); }, /** * Add that to this, and return a new array containing the result. * * @param that The array to be added to this one. * * @returns A new MdArray containing the values of that + this. * * @method */ add: function(that) { return this.applyOp(that, function(x, y) { return x+y; }); }, /** * Subtract that from this, and return a new MdArray containing the result. * * @param that The array to be subtracted from this one. * * @returns A new MdArray containing the values of this - that. * * @method */ sub: function(that) { return this.applyOp(that, function(x, y) { return x-y; }); }, /** * Multiply this by that and return a new MdArray containing the result. * * @param that The array to be multiplied with this one. * * @returns A new MdArray containing the values of this * that. * * @method */ mul: function(that) { return this.applyOp(that, function(x, y) { return x*y; }); }, /** * Divide this by that and return a new MdArray containing the result. * * @param that The array to divide this by. * * @returns A new MdArray containing the values of this / that. * * @method */ div: function(that) { if (that instanceof MdArray) { if (_us.some(that.data, function(x) { return x == 0; })) { throw new Error(&quot;MdArray.div: divisor contains a zero.&quot;); } } else { if (that == 0) { throw new Error(&quot;MdArray.div: Attempt to divide by zero.&quot;); } } return this.applyOp(that, function(x, y) { return x/y; }); }, /** * Return the dot product of this and that. * * Note: This method only runs for 1 or 2 dimensional MdArrays. * * @param that An MdArray to be dotted with this one. * * @returns A value if this and that are 1-dimensional arrays, or a m x p * size MdArray where m is the number of rows in this, and p is the * number of columns in that. */ dot: function(that) { assert(this.dims.length &lt;= 2, &quot;dot is only defined for 1 or 2 dimensional MdArrays.&quot;); assert(this.dims.length === that.dims.length, &quot;dot is only defined between MdArray's with the same number of dimensions.&quot;); if (this.dims.length === 1) { assert(this.dSize === that.dSize, &quot;dot is only defined for 1 dimensional MdArray's of the same size.&quot;); return _us.reduce(_us.zip(this.data, that.data), function(memo, val) { return memo + val[0] * val[1]; }, 0); } else { var dotProd = MdArray.zeros({shape: [this.dims[0], that.dims[1]]}); for (var i = 0; i &lt; this.dims[0]; i++) { for (var j = 0; j &lt; that.dims[1]; j++) { var rowData = this.slice([i.toString(), &quot;:&quot;]).flatten(); var colData = that.slice([&quot;:&quot;, j.toString()]).flatten(); var val = _us.reduce(_us.zip(rowData, colData), function(memo, v) { return memo + v[0] * v[1]; }, 0); dotProd.set(val, i, j); } } return dotProd; } }, /** * Return a new array containing the transpose of this array or, if inPlace * is true, modify this array to be Transposed. * * @param args An optional object containing a boolean valued key inPlace. * * @returns A new array, or this. * * @method */ T: function(args /* inPlace == true/false =&gt; default false*/) { var inPlace = (args &amp;&amp; args.inPlace) || false; if (inPlace) { this.strides = this.strides.reverse(); return this; } else { var transposed = new MdArray( {data : this.data.slice(0), shape: this.dims.slice(0)} ); transposed.strides.reverse(); return transposed; } }, /** * Apply function f to each element of the MdArray. * * @param f A function that can be applied to elements of this. * * @method */ foreach: function(f) { var indices = enumerateDims(this.dims); for (var i = 0; i &lt; indices.length; i++) { f(this.data[this.findIndex(indices[i])]); } }, /** * Create and return an ArrayView object representing a slice of this * array. * * The sliceInfo parameter is an array of strings that follow the python * numpy array slice syntax. So for example: * * - &quot;2:5&quot; would be taken to mean take just all the values between 2 and 5, * - &quot;:&quot; would mean take all possible values for this dimension. * - &quot;:5&quot; would mean take all values up to 5, * and so on. * * @param sliceInfo An array containing strings of sliceInfo. * * @return A new ArrayView object appropriately created for the slice. * * @method */ slice: function(sliceInfo) { return new ArrayView ( this.data, this.dims.slice(0), this.strides.slice(0), sliceInfo ); } }; /* * Factory functions. * * Includes: * - arange Create an MdArray containing a range of numbers. * - zeros Create an MdArray containing 0s. * - ones Create an MdArray containing 1s. */ /** * Return an MdArray of zeros. Args are the shape of the array. * * @param args An object containing a shape field with an array of * dimensions. * * @returns An MdArray of the requested shape containing all zeros. */ MdArray.zeros = function(args /* args.shape = [d1, d2, ...dn] */) { 'use strict'; args.fill = 0; return MdArray.createFilled(args); }; /** * Return an MdArray of ones. Args are the shape of the array. * * @param args An object containing a shape field with an array of * dimensions. * * @returns An MdArray of the requested shape containing all ones. */ MdArray.ones = function(args /* args.shape = [d1, d2, ...dn] */) { 'use strict'; args.fill = 1; return MdArray.createFilled(args); }; /** * Return an MdArray of containing the requested fill value. * * @param args An object containing a shape field with an array of * dimensions, and a fill field. * * @returns An MdArray of the requested shape containing the repeated fill value. */ MdArray.createFilled = function(args/* args.shape = [d1, d2, ...dn], args.val = n */) { 'use strict'; var fillVal = args.fill || 0; var ma = Object.create(MdArray.prototype); var tSize = _us.reduce(args.shape, function(memo, val) { return memo * val; }, 1); var data = new Array(tSize); for (var i = 0; i &lt; tSize; i++) { data[i] = fillVal; } ma.data = data; ma.tSize = tSize; ma.dSize = ma.data.length; ma.dims = args.shape; ma.strides = getStrides(ma.dims); return ma; }; /** * Create an MdArray containing a range of numeric values. * * @param args An object containing a shape field with an array of dimensions, * an end field, and an optional start and by field. * * @return An MdArray containing the requested range of values. */ MdArray.arange = function(args /* [start,] end [, by] [, shape] */) { 'use strict'; var start = args.start || 0; var end = args.end; var by = args.by || 1; var rangeVal = _us.range(start, end, by); var shapeVal = args.shape || [rangeVal.length]; return new MdArray({data : rangeVal, shape : shapeVal}); }; /** * Given the dimensions of an MdArray, return an array of strides for the * array. * * @param dims An array of dimensions for the MdArray. * * @returns An array containing the strides for the MdArray. */ function getStrides(dims) { 'use strict'; if (dims.length == 1) { return [1]; } var reversed = dims.slice(0).reverse(); var strides = []; _us.each(reversed, function(val, idx, arr) { if (idx == 0) { strides.unshift(1); strides.unshift(val); } else if (idx != arr.length - 1) { strides.unshift(val * strides[0]); } }); return strides; } /** * @constructor * @augments MdArray * Construct an ArrayView object */ function ArrayView(orgData, orgDims, orgStrides, sliceInfo) { this.data = orgData; this.dims = orgDims; this.strides = orgStrides; this.slices = processSlices(orgDims, sliceInfo); return this; } ArrayView.prototype = Object.create(MdArray.prototype); _us.extend (ArrayView.prototype, { // Constructor constructor: ArrayView, /** * Return the required 1-d javascript array index indicated by the supplied * index coordinates. * * @param idx An array containing the coordinate of the requested element. * @method */ findIndex: function(idx) { 'use strict'; var myThis = this; assert(idx.length == this.strides.length, &quot;Wrong number of arguments to index array with &quot; + this.strides.length + &quot; dimensions.&quot;); var md_idx = _us.zip(idx, this.slices, this.strides); assert(_us.every(md_idx, function(val, idx) { return (val[0] + val[1].start) &lt; myThis.dims[idx]; }), &quot;ArrayView: Index out of range.&quot;); return _us.reduce(md_idx, function(memo, val) { return memo + (val[0] + val[1].start) * val[2]; }, 0); }, /** * Return a string representation of the the multi-Dimensional array. * * @returns A readable string for the array. * @method */ toString: function() { var idxInfo = _us.zip(this.slices.slice(0), this.strides.slice(0)); function ts(ss, idx, data) { s = &quot;[&quot;; if (ss.length == 1) { s += &quot;\\t&quot;; var firstDim = ss[0]; for (var i = firstDim[0].start; i &lt; firstDim[0].end; i++) { s += &quot; &quot; + data[idx + i * firstDim[1]]; } s += &quot; ]&quot;; } else { var firstDim = _us.first(ss); for (var i = firstDim[0].start; i &lt; firstDim[0].end; i++) { s += ts(_us.rest(ss), idx + i * firstDim[1], data); if (i &lt; firstDim[0].end - 1) { s += &quot;\\n&quot;; } } s += &quot;]&quot;; } if (ss.length == idxInfo.length) { s += &quot;\\n&quot;; } return s; } return ts(idxInfo, 0, this.data); }, /** * Return a new array containing the data of the view. */ flatten: function() { var flattened = []; this.foreach(function(x) {flattened.push(x); }); return flattened; }, foreach: function(f) { var indices = enumerateSlices(this.slices); for (var i = 0; i &lt; indices.length; i++) { f(this.data[this.findIndex(indices[i])]); } }, enumerateIndices: function() { return enumerateSlices(this.slices); }, setSlice : function(vals) { var sliceIndices = this.enumerateIndices(); for (var i = 0; i &lt; vals.length; i++) { this.set.apply(this, [vals[i]].concat(sliceIndices.shift())); } return; } }); /** * Return an array of objects with start and end index values calculated * from the values in dims and sliceInfo. * * @param dims An array containing the dimensions of the original MdArray. * @param sliceInfo An array of slice strings. * * @returns An array of objects, each of which has a start and end indicating * the start and end of a slice for a particular dimension. */ function processSlices(dims, sliceInfo) { assert(dims.length === sliceInfo.length, &quot;ArrayView: dims and sliceInfo parameters must be of the same length.&quot;); var ds = _us.zip(dims, sliceInfo); var processedSlices = _us.map(ds, function(val) { var dim = val[0]; var si = val[1].replace(/\\s/g, &quot;&quot;); var siSplits = si.split(&quot;:&quot;); var splitObj = {}; if (siSplits.length === 1) { // Just an index splitObj.start = parseInt(siSplits[0]); splitObj.end = Math.min(splitObj.start + 1, dim); } else { splitObj.start = (siSplits[0].length &gt; 0) ? parseInt(siSplits[0]) : 0; splitObj.end = (siSplits[1].length &gt; 0) ? parseInt(siSplits[1]) : dim; } assert(splitObj.start &gt;= 0 &amp;&amp; splitObj.start &lt; splitObj.end, &quot;ArrayView: First slice index must be &gt; 0 and &lt; the second index.&quot;); assert(splitObj.end &lt;= dim, &quot;ArrayView: Second slice index must be less than dim&quot;); return splitObj; }); return processedSlices; } /** * Return a list of all coordinates for the given MdArray. * * @param dims An array of dimensions for an MdArray. * * @returns An ordered list containing a coordinate for every element of the * MdArray. */ function enumerateDims(dims) { if (dims.length == 0) { return []; } var firstRange = _us.map(_us.range(_us.first(dims)), function(val) { return [val]; }); if (dims.length == 1) { return firstRange; } else { var restDims = enumerateDims(_us.rest(dims)); var final = []; _us.each(firstRange, function(val) { var final1 = _us.map(restDims, function(rVal) { return val.slice(0).concat(rVal.slice(0)); }); final = final.concat(final1); }); return final; } } /** * Return a list of all coordinates for the given MdArray. * * @param dims An array of dimensions for an MdArray. * * @returns An ordered list containing a coordinate for every element of the * MdArray. */ function enumerateSlices(slices) { if (slices.length == 0) { return []; } var firstSlice = _us.first(slices); var firstRange = _us.map(_us.range(firstSlice.start, firstSlice.end), function(val) { return [val - firstSlice.start]; }); if (slices.length == 1) { return firstRange; } else { var restSlices = enumerateSlices(_us.rest(slices)); var final = []; _us.each(firstRange, function(val) { var final1 = _us.map(restSlices, function(rVal) { return val.slice(0).concat(rVal.slice(0)); }); final = final.concat(final1); }); return final; } } /** * Raise an error if possible, when there is a violation of the expectations * of the ml-ndarray module. */ function assert(condition, message) { 'use strict'; if (!condition) { message = message || &quot;Assertion failed&quot;; if (typeof Error !== &quot;undefined&quot;) { throw new Error(message); } throw message; } } module.exports = MdArray; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Classes ArrayViewMdArray Global assertenumerateDimsenumerateSlicesfindIndexflattengetStridesprocessSlicestoString Global Methods assert() Raise an error if possible, when there is a violation of the expectationsof the ml-ndarray module. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 717 enumerateDims(dims) Return a list of all coordinates for the given MdArray. Parameters: Name Type Description dims An array of dimensions for an MdArray. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 654 Returns: An ordered list containing a coordinate for every element of the MdArray. enumerateSlices(dims) Return a list of all coordinates for the given MdArray. Parameters: Name Type Description dims An array of dimensions for an MdArray. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 686 Returns: An ordered list containing a coordinate for every element of the MdArray. findIndex(idx) Return the required 1-d javascript array index indicated by the suppliedindex coordinates. Parameters: Name Type Description idx An array containing the coordinate of the requested element. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 526 flatten() Return a new array containing the data of the view. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 583 getStrides(dims) Given the dimensions of an MdArray, return an array of strides for thearray. Parameters: Name Type Description dims An array of dimensions for the MdArray. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 482 Returns: An array containing the strides for the MdArray. processSlices(dims, sliceInfo) Return an array of objects with start and end index values calculatedfrom the values in dims and sliceInfo. Parameters: Name Type Description dims An array containing the dimensions of the original MdArray. sliceInfo An array of slice strings. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 617 Returns: An array of objects, each of which has a start and end indicating the start and end of a slice for a particular dimension. toString() Return a string representation of the the multi-Dimensional array. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 548 Returns: A readable string for the array. × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes ArrayViewMdArray Global assertenumerateDimsenumerateSlicesfindIndexflattengetStridesprocessSlicestoString Classes Classes ArrayView MdArray × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes ArrayViewMdArray Global assertenumerateDimsenumerateSlicesfindIndexflattengetStridesprocessSlicestoString × Search results Close "},"ArrayView.html":{"id":"ArrayView.html","title":"Class: ArrayView","body":" DocStrap Classes ArrayViewMdArray Global assertenumerateDimsenumerateSlicesfindIndexflattengetStridesprocessSlicestoString Class: ArrayView ArrayView new ArrayView() Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 506 Extends MdArray Methods add(that) Add that to this, and return a new array containing the result. Parameters: Name Type Description that The array to be added to this one. Inherited From: MdArray#add Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 228 Returns: A new MdArray containing the values of that + this. applyOp(that, opFn) Apply the function opFn to all pairs of matching elements in this and that. Parameters: Name Type Description that The other object that is part of this operation. opFn The operation to be applied to pairs of elements from this and that. Inherited From: MdArray#applyOp Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 181 Returns: A new MdArray containing the results of applying opFn to this and that. compatible(that) Test whether the MdArray that is compatible with this one, so thatelement wise operations are able to be applied between this and that. Parameters: Name Type Description that An MdArray object to have it's dimensions checked against this. Inherited From: MdArray#compatible Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 214 Returns: true =&gt; this and that are compatible, false otherwise. div(that) Divide this by that and return a new MdArray containing the result. Parameters: Name Type Description that The array to divide this by. Inherited From: MdArray#div Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 267 Returns: A new MdArray containing the values of this / that. dot(that) Return the dot product of this and that. Note: This method only runs for 1 or 2 dimensional MdArrays. Parameters: Name Type Description that An MdArray to be dotted with this one. Inherited From: MdArray#dot Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 294 Returns: A value if this and that are 1-dimensional arrays, or a m x p size MdArray where m is the number of rows in this, and p is the number of columns in that. findIndex(idx) Return the required 1-d javascript array index indicated by the suppliedindex coordinates. Parameters: Name Type Description idx An array containing the coordinate of the requested element. Inherited From: MdArray#findIndex Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 110 flatten() Return the data of this MdArray as a flat array. Inherited From: MdArray#flatten Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 165 foreach(f) Apply function f to each element of the MdArray. Parameters: Name Type Description f A function that can be applied to elements of this. Inherited From: MdArray#foreach Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 355 get() Get the value of the element indexed by the coordinate values in thearguments. Inherited From: MdArray#get Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 81 Returns: The value at the array position specified. mul(that) Multiply this by that and return a new MdArray containing the result. Parameters: Name Type Description that The array to be multiplied with this one. Inherited From: MdArray#mul Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 254 Returns: A new MdArray containing the values of this * that. set(val) Set the value in the array element indexed by the remaining values inarguments. Parameters: Name Type Description val The value to be assigned into the array. Inherited From: MdArray#set Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 96 slice(sliceInfo) Create and return an ArrayView object representing a slice of thisarray. The sliceInfo parameter is an array of strings that follow the pythonnumpy array slice syntax. So for example: &quot;2:5&quot; would be taken to mean take just all the values between 2 and 5, &quot;:&quot; would mean take all possible values for this dimension. &quot;:5&quot; would mean take all values up to 5,and so on. Parameters: Name Type Description sliceInfo An array containing strings of sliceInfo. Inherited From: MdArray#slice Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 380 Returns: A new ArrayView object appropriately created for the slice. sub(that) Subtract that from this, and return a new MdArray containing the result. Parameters: Name Type Description that The array to be subtracted from this one. Inherited From: MdArray#sub Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 241 Returns: A new MdArray containing the values of this - that. T(args) Return a new array containing the transpose of this array or, if inPlaceis true, modify this array to be Transposed. Parameters: Name Type Description args An optional object containing a boolean valued key inPlace. Inherited From: MdArray#T Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 332 Returns: A new array, or this. toString() Return a string representation of the the multi-Dimensional array. Inherited From: MdArray#toString Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 129 Returns: A readable string for the array. × Search results Close "},"MdArray.html":{"id":"MdArray.html","title":"Class: MdArray","body":" DocStrap Classes ArrayViewMdArray Global assertenumerateDimsenumerateSlicesfindIndexflattengetStridesprocessSlicestoString Class: MdArray MdArray The MdArray class provides a multi-dimensional array likeabstraction for javascript. Construct an Ml_ndarray object from it's shape in terms of rows,columns,and any other dimensions it has. The parameter to the constructor is a javascript object containing keywordarguments. Eg.: { data: [1, 2, 3, 4], shape: [2, 2]} new MdArray(arrayArgs) Parameters: Name Type Description arrayArgs An object containing the keyword args for the constructor. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 37 Methods &lt;static&gt; arange(args) Create an MdArray containing a range of numeric values. Parameters: Name Type Description args An object containing a shape field with an array of dimensions, an end field, and an optional start and by field. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 464 Returns: An MdArray containing the requested range of values. &lt;static&gt; createFilled(args) Return an MdArray of containing the requested fill value. Parameters: Name Type Description args An object containing a shape field with an array of dimensions, and a fill field. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 436 Returns: An MdArray of the requested shape containing the repeated fill value. &lt;static&gt; ones(args) Return an MdArray of ones. Args are the shape of the array. Parameters: Name Type Description args An object containing a shape field with an array of dimensions. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 422 Returns: An MdArray of the requested shape containing all ones. &lt;static&gt; zeros(args) Return an MdArray of zeros. Args are the shape of the array. Parameters: Name Type Description args An object containing a shape field with an array of dimensions. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 408 Returns: An MdArray of the requested shape containing all zeros. add(that) Add that to this, and return a new array containing the result. Parameters: Name Type Description that The array to be added to this one. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 228 Returns: A new MdArray containing the values of that + this. applyOp(that, opFn) Apply the function opFn to all pairs of matching elements in this and that. Parameters: Name Type Description that The other object that is part of this operation. opFn The operation to be applied to pairs of elements from this and that. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 181 Returns: A new MdArray containing the results of applying opFn to this and that. compatible(that) Test whether the MdArray that is compatible with this one, so thatelement wise operations are able to be applied between this and that. Parameters: Name Type Description that An MdArray object to have it's dimensions checked against this. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 214 Returns: true =&gt; this and that are compatible, false otherwise. div(that) Divide this by that and return a new MdArray containing the result. Parameters: Name Type Description that The array to divide this by. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 267 Returns: A new MdArray containing the values of this / that. dot(that) Return the dot product of this and that. Note: This method only runs for 1 or 2 dimensional MdArrays. Parameters: Name Type Description that An MdArray to be dotted with this one. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 294 Returns: A value if this and that are 1-dimensional arrays, or a m x p size MdArray where m is the number of rows in this, and p is the number of columns in that. findIndex(idx) Return the required 1-d javascript array index indicated by the suppliedindex coordinates. Parameters: Name Type Description idx An array containing the coordinate of the requested element. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 110 flatten() Return the data of this MdArray as a flat array. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 165 foreach(f) Apply function f to each element of the MdArray. Parameters: Name Type Description f A function that can be applied to elements of this. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 355 get() Get the value of the element indexed by the coordinate values in thearguments. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 81 Returns: The value at the array position specified. mul(that) Multiply this by that and return a new MdArray containing the result. Parameters: Name Type Description that The array to be multiplied with this one. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 254 Returns: A new MdArray containing the values of this * that. set(val) Set the value in the array element indexed by the remaining values inarguments. Parameters: Name Type Description val The value to be assigned into the array. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 96 slice(sliceInfo) Create and return an ArrayView object representing a slice of thisarray. The sliceInfo parameter is an array of strings that follow the pythonnumpy array slice syntax. So for example: &quot;2:5&quot; would be taken to mean take just all the values between 2 and 5, &quot;:&quot; would mean take all possible values for this dimension. &quot;:5&quot; would mean take all values up to 5,and so on. Parameters: Name Type Description sliceInfo An array containing strings of sliceInfo. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 380 Returns: A new ArrayView object appropriately created for the slice. sub(that) Subtract that from this, and return a new MdArray containing the result. Parameters: Name Type Description that The array to be subtracted from this one. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 241 Returns: A new MdArray containing the values of this - that. T(args) Return a new array containing the transpose of this array or, if inPlaceis true, modify this array to be Transposed. Parameters: Name Type Description args An optional object containing a boolean valued key inPlace. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 332 Returns: A new array, or this. toString() Return a string representation of the the multi-Dimensional array. Source: /Users/michaelw/Google Drive/js/MdArray/lib/MdArray.js, line 129 Returns: A readable string for the array. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
